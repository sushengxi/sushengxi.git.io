<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="中文，英文">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/sushengxi.git.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/sushengxi.git.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/sushengxi.git.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/sushengxi.git.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/sushengxi.git.io/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/sushengxi.git.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/sushengxi.git.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="h5，javascript,css,node,java,mysql,mongodb">
<meta property="og:type" content="website">
<meta property="og:title" content="little su的博客">
<meta property="og:url" content="https://github.com/sushengxi/sushengxi.git.io.git/index.html">
<meta property="og:site_name" content="little su的博客">
<meta property="og:description" content="h5，javascript,css,node,java,mysql,mongodb">
<meta property="og:locale" content="中文，英文">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="little su的博客">
<meta name="twitter:description" content="h5，javascript,css,node,java,mysql,mongodb">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/sushengxi.git.io/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://github.com/sushengxi/sushengxi.git.io.git/">





  <title>little su的博客</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="中文，英文">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/sushengxi.git.io/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">little su的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">开发中遇到的问题及一些知识的梳理</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/sushengxi.git.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/sushengxi.git.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/sushengxi/sushengxi.git.io.git/sushengxi.git.io/2018/05/05/什么是collection/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="little su">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/sushengxi.git.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="little su的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/sushengxi.git.io/2018/05/05/什么是collection/" itemprop="url">java中collection的认识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-05T16:25:30+08:00">
                2018-05-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="java中Collection的认识"><a href="#java中Collection的认识" class="headerlink" title="java中Collection的认识"></a>java中Collection的认识</h2><p>集合Conllection的基本概念：<br>1、集合的基本认识：如StringBuffer&amp;StringBuilder是集合（存储的对象类型是String）。数组、对象与其很相似，但是还有区别。<br>2、集合的由来：对象用于封装特有数据，对象多了需要存储，如果对象的个数不确定，就需要使用集合来进行存储。<br>3、集合的特点：<br>    （1）用于存储对象的容器；即集合中存储的元素是对象<br>    （2）集合的长度是可变的；<br>    （3）集合是不可以存储基本数据类型的；（集合存储基本数据类型时会先进行自动封装成其对应的对象后再进行存储）<br>4、集合框架体系：<br>    集合是用于存储对象的容器。而每种容器内部都有其独特的数据结构，正因为不同的容器内部数据结构不同，使其各自有自己独特的使用场景。虽然每个<br>容器有其独特的结构但是类似的容器还是存在共性的（共性操作方法），所以这些共性方法能被不断抽取，最终形成了集合框架体系。<br>5、集合框架的顶层接口（根接口）：Collection<br>    Collection的常见方法：<br>    （1）添加<br>        boolean add(E e);(这个参数e就是一个对象)<br>        boolean add(Collection&lt;? extends E&gt;” c);<br>    （2）删除<br>        boolean remove(Object o);<br>        boolean removeAll(Collection&lt;? extends E&gt; c)<br>        void clear()；<br>    （3）判断<br>        a.判断集合中是否有元素：boolean isEmpty();<br>        b.判断集合中是否包含某个元素：boolean contains(Object o);<br>        c.判断集合中是否包含某些元素：boolean contains(Collection&lt;?&gt; c);</p>
<pre><code>（4）获取
   a.获取集合中元素个数：int size();
   b.遍历集合中所有元素：Iterator&amp;lt;E&amp;gt; iterator();
   c.判断两个集合中是否存在相同的元素并保留两个集合中相同的元素删除不同的元素：boolean retainAll(Collection&amp;lt;?&amp;gt; c);
（5）其他
   将集合中元素转为数组：a.    Ojbect[] toArray();
                 b.    &amp;lt;T&amp;gt;  T[] toArray();   泛型
</code></pre><p>6、迭代器 Iterator<br>    （1）通过集合对象获取其对应的Iterator对象；<br>    （2）判断是否存在下一个元素；<br>    （3）取出该元素并将迭代器对象指向下一个元素；</p>
<pre><code>Iterator iterator():取出元素的方式：迭代器。
    该对象必须依赖于具体容器，因为每一个容器的数据结构都不同。
    所以该迭代器对象是在容器中进行内部实现的。
    对于使用容器者而言，具体的实现不重要，只要通过容器获取到该实现的迭代器的对象即可，也就是iterator方法。
</code></pre><p>7、Collection两大体系：链表List、集合Set<br>    List特点：元素有序；元素可以重复；元素都有索引（角标）<br>    Set 特点：元素无序；元素不可以重复；</p>
<pre><code>List特有的常见方法：有一个共性就是可以操作角标。
</code></pre><p>8、List三大常用集合：<br>    Vector:内部是数组数据结构，是同步的（线程安全的）。增删查询都很慢。<br>    ArrayList:内部是数组数据结构，是不同步的（线程不安全的）。替代了Vector。查询速度快，增删比较慢。<br>    LinkedList:内部是链表数据结构，是不同步的（线程不安全的）。增删元素速度快。</p>
<p>9、Set常用集合：<br>    Set中方法与Collection一致。</p>
<pre><code>（1）HashSet：内部数据结构是哈希表，是不同步的。
    Set集合中元素都必须是唯一的，HashSet作为其子类也需保证元素的唯一性。
    判断元素唯一性的方式：
       通过存储对象（元素）的hashCode和equals方法来完成对象唯一性的。
       如果对象的hashCode值不同，那么不用调用equals方法就会将对象直接存储到集合中；
       如果对象的hashCode值相同，那么需调用equals方法判断返回值是否为true，
        若为false, 则视为不同元素，就会直接存储；
        若为true， 则视为相同元素，不会存储。

 PS：如果要使用HashSet集合存储元素，该元素的类必须覆盖hashCode方法和equals方法。
 一般情况下，如果定义的类会产生很多对象，通常都需要覆盖equals，hashCode方法。建立对象判断是否相同的依据。

（2）TreeSet：保证元素唯一性的同时可以对内部元素进行排序，是不同步的。
    判断元素唯一性的方式：
       根据比较方法的返回结果是否为0，如果为0视为相同元素，不存；如果非0视为不同元素，则存。
    TreeSet对元素的排序有两种方式：
        方式一：使元素（对象）对应的类实现Comparable接口，覆盖compareTo方法。这样元素自身具有比较功能。
        方式二：使TreeSet集合自身具有比较功能，定义一个类实现Comparable接口覆盖其compareTo方法。（相当于自定义了一个比较器）
            将该类对象作为参数传递给TreeSet集合的构造函数。（TreeSet(Comparator&amp;lt;? super E&amp;gt; c) ）
            ArrayList和Vector有什么区别？HashMap和HashTable有什么区别？
</code></pre><p>   Vector和HashTable是线程安全的同步的  ArrayList和HashMap性能比Vector和HashTable好<br> 大致讲解java集合的体系结构<br>   List、Set、Map是这个集合体系中最主要的三个接口。<br>      其中List和Set继承自Collection接口。<br>      Set不允许元素重复。HashSet和TreeSet是两个主要的实现类。<br>      List有序且允许元素重复。ArrayList、LinkedList和Vector是三个主要的实现类。<br>      Map也属于集合系统，但和Collection接口不同。Map是key对value的映射集合，其中key列就是一个集合。key不能重复，但是value可以重复。HashMap、TreeMap和Hashtable是    三个主要的实现类。<br>      SortedSet和SortedMap接口对元素按指定规则排序，SortedMap是对key列进行排序。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/sushengxi/sushengxi.git.io.git/sushengxi.git.io/2018/01/30/Nodejs-app-use的使用/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="little su">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/sushengxi.git.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="little su的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/sushengxi.git.io/2018/01/30/Nodejs-app-use的使用/" itemprop="url">Nodejs app.use的使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-30T15:22:30+08:00">
                2018-01-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#Nodejs中间件<br>&ensp;&ensp;app.use([path,] function [, function…])<br>&ensp;&ensp;在path上安装中间件，如果path没有被设定，那么默认为”/”。<br>&ensp;&ensp;当为路由设置一个匹配路径后，路由会匹配该路径及该路径下所有的路径。例如：<br>&ensp;&ensp;app.use(‘/apple’, …)会匹配请求路径’/apple’, ‘/apple/images’,<br>&ensp;&ensp;‘/apple/images/news’等。<br>&ensp;&ensp;在中间件中req.originalUrl是req.baseUrl和req.path的组合，如下面的例子所示：</p>
<hr>
<p><img src="usezjj1.png" alt="mongodb"></p>
<hr>
<p>&ensp;&ensp;在path路径上安装中间件，每当请求的路径的基路径和该path匹配时，都会导致该中间件函数被执行。例如，默认路径’/’，即&ensp;&ensp;当中间件没有设置安装路径时，任何向该应用的请求都会触发该中间件函数.如果设置了基路径则会进入基路径对应的router如&ensp;&ensp;下列 基路径”/openapi” 会进入baseRouter路由下面</p>
<hr>
<p><img src="router.png" alt="mongodb"></p>
<hr>
<p>路径可以是一个字符也可以是一个模式一个正则表达式来表示或者他们的组合形式。例如：</p>
<hr>
<p><img src="path.png" alt="mongodb"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/sushengxi/sushengxi.git.io.git/sushengxi.git.io/2018/01/24/javascript队列/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="little su">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/sushengxi.git.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="little su的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/sushengxi.git.io/2018/01/24/javascript队列/" itemprop="url">javascript数据接口==>队列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-24T17:58:25+08:00">
                2018-01-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="javascript数据结构队列"><a href="#javascript数据结构队列" class="headerlink" title="javascript数据结构队列"></a>javascript数据结构队列</h2><p>其实队列跟栈有很多相似的地方，包括其中的一些方法和使用方式，只是队列使用了与栈完全不同的原则，栈是后进先出原则，而队列是先进先出（First In First Out）。 队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。<br>　　队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）线性表。<br>　　我们对队列有了基本的了解，那么我们来看看如何实现队列。其实跟栈的实现极为类似，只是入队和出队的方法稍有不同，那么我们来看看一个完整的队列需要哪些方法：<br>　　　　1、enqueue(element(s))，入队，向队列尾部添加一个或者多个元素。<br>　　　　2、dequeue()，出队，移除队列中的第一个元素，也就是队列最前面的元素，并返回该元素。<br>　　　　3、front()，获取队列最前面的元素，返回队列中第一个元素（最先被添加，也是最先被移除的元素）。队列并不移除该元素。<br>　　　　4、isEmpty()，判断队列是否不包含任何元素。<br>　　　　5、size()，返回队列的元素总数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Queue() &#123;</span><br><span class="line">   this.dataStroe = [];//队列元素的容器</span><br><span class="line">   this.enqueue = enqueue;//添加元素</span><br><span class="line">   this.dequeue = dequeue;//删除元素</span><br><span class="line">   this.front = front;//获取队列的第一个元素</span><br><span class="line">   this.isEmpty = isEmpty;//队列是否为空</span><br><span class="line">   this.size = length;//队列元素的个数</span><br><span class="line">   this.print = print;//打印元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function enqueue (ele) &#123;</span><br><span class="line">    this.dataStroe.push(ele); //向队列添加元素</span><br><span class="line">&#125;</span><br><span class="line">function dequeue() &#123;</span><br><span class="line">    return this.dataStroe.shift();//队列删除元素</span><br><span class="line">&#125;</span><br><span class="line">function front() &#123;</span><br><span class="line">    return this.dataStroe[0];//获取队列的第一个元素</span><br><span class="line">&#125;</span><br><span class="line">function isEmpty() &#123;</span><br><span class="line">    return this.dataStroe.length == 0;//判断队列是否为空</span><br><span class="line">&#125;</span><br><span class="line">function length() &#123;</span><br><span class="line">    return this.dataStroe.length;//队列元素的个数</span><br><span class="line">&#125;</span><br><span class="line">function print() &#123;</span><br><span class="line">    return this.dataStroe.toString();//打印队列的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码我们用class和闭包的知识修改一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">var Queue = (function() &#123;</span><br><span class="line">    const wm = new WeakMap();</span><br><span class="line">    class Queue &#123;</span><br><span class="line">        constructor() &#123;</span><br><span class="line">            // super();</span><br><span class="line">            wm.set(this,[]);</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue (ele) &#123;</span><br><span class="line">            let queue = wm.get(this);</span><br><span class="line">            queue.push(ele)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dequeue() &#123;</span><br><span class="line">            let queue = wm.get(this);</span><br><span class="line">            let item = queue.shift();</span><br><span class="line">            return item;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        front() &#123;</span><br><span class="line">            return wm.get(this)[0];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        isEmpty() &#123;</span><br><span class="line">            return wm.get(this).length == 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        print() &#123;</span><br><span class="line">            return wm.get(this).toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return Queue;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p>
<hr>
<p>队列又分为优先队列和循环队列<br>优先队列：<br>普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">function precedenceQueue() &#123;</span><br><span class="line">    var dataStroe = [];</span><br><span class="line">    //添加队列元素</span><br><span class="line">    this.enqueue = enqueue;</span><br><span class="line">    //删除元素</span><br><span class="line">    this.dequeue = dequeue;</span><br><span class="line">    //获取队列头元素</span><br><span class="line">    this.front = front;</span><br><span class="line">    //获取队列元素的个数</span><br><span class="line">    this.size = length;</span><br><span class="line">    //打印队列所有元素</span><br><span class="line">    this.print = print;</span><br><span class="line"></span><br><span class="line">    //定义创建优先级元素的函数</span><br><span class="line">    function createdPrecedenceEle(ele,precedence) &#123;</span><br><span class="line">        this.element = ele;</span><br><span class="line">        this.precedence = precedence;</span><br><span class="line">    &#125;</span><br><span class="line">    //添加队列元素</span><br><span class="line">    function enqueue(ele,precedence) &#123;</span><br><span class="line">        var precedeceEle = new createdPrecedenceEle(ele,precedence);</span><br><span class="line">        var added = false;</span><br><span class="line">        for(var i = 0; i &lt; dataStroe.length; i++) &#123;</span><br><span class="line">            if(dataStroe[i].precedence &lt; precedeceEle.precedence ) &#123;</span><br><span class="line">                dataStroe.splice(i,0,precedeceEle)</span><br><span class="line">                added = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!added) &#123;</span><br><span class="line">            dataStroe.push(precedeceEle)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   //删除元素</span><br><span class="line">   function dequeue() &#123;</span><br><span class="line">       return dataStroe.shift();</span><br><span class="line">   &#125;</span><br><span class="line">   //获取队列头部的元素</span><br><span class="line">   function front() &#123;</span><br><span class="line">       return dataStroe[0];</span><br><span class="line">   &#125;</span><br><span class="line">   //获取队列元素的个数</span><br><span class="line">   function size() &#123;</span><br><span class="line">       return dataStroe.length;</span><br><span class="line">   &#125;</span><br><span class="line">   //打印队列的元素</span><br><span class="line">   function print() &#123;</span><br><span class="line">       var sigleStirng = &quot;&quot;;</span><br><span class="line">       for(var i = 0; i &lt; dataStroe.length; i++) &#123;</span><br><span class="line">           sigleStirng +=(dataStroe[i].element+&quot;---&quot;+dataStroe[i].precedence+&quot;    &quot;)</span><br><span class="line">       &#125;</span><br><span class="line">       return sigleStirng;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>循环队列<br>每次循环的时候（从队列头部）取出一个队列头部，再把这个元素加入到队列的尾部，循环 n 次，循环停止时指向的元素删除，直到队列中只剩下一个元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function loopQueue(list,number) &#123;</span><br><span class="line">    var queue = new Queue();</span><br><span class="line">    console.log(queue)</span><br><span class="line">     for(var i = 0; i &lt; list.length; i++) &#123;</span><br><span class="line">         queue.enqueue(list[i]);</span><br><span class="line">     &#125;</span><br><span class="line">     console.log(queue.size())</span><br><span class="line">     var failName = &quot;&quot;;</span><br><span class="line">     while(queue.size() &gt;1) &#123;</span><br><span class="line">         for(var i = 0; i &lt; number; i++) &#123;</span><br><span class="line">             //每次循环将第一个元素放到队列的尾部</span><br><span class="line">             queue.enqueue(queue.dequeue());</span><br><span class="line">         &#125;</span><br><span class="line">         //出局的元素</span><br><span class="line">         failName = queue.dequeue();</span><br><span class="line">     &#125;</span><br><span class="line">     //返回就是最后剩下的一个元素</span><br><span class="line">     console.log(queue.dequeue)</span><br><span class="line">     return queue.dequeue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/sushengxi/sushengxi.git.io.git/sushengxi.git.io/2018/01/23/javascript数据结构-栈/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="little su">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/sushengxi.git.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="little su的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/sushengxi.git.io/2018/01/23/javascript数据结构-栈/" itemprop="url">javascript数据结构==>栈</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-23T15:54:54+08:00">
                2018-01-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##javascript数据结构==栈<br>&ensp;&ensp;javascript数据结构==栈<br>&ensp;&ensp;栈，又叫堆栈，是和列表类似的一种数据结构，但是却更高效，因为栈内的元素只能通过列表的一端访问，称为栈顶，数据只能&ensp;&ensp;在栈顶添加或删除，遵循 先入后出(LIFO，last-in-first-out) 的原则。<br>&ensp;&ensp;对栈的操作主要有两种，一是将一个元素压入栈，push方法，另一个就是将栈顶元素出栈，pop方法。除此之外，栈还有其他的&ensp;&ensp;一些属性和方法：查看当前栈顶的元素值，我们使用 peek 方法，它仅仅返回栈顶元素值，并不删除它；clear 方法用于清空当&ensp;&ensp;前栈内的所有元素；top属性记录当前栈顶位置；length方法返回当前栈内元素总数等；接着我们定义栈的数据类型，并利用JS&ensp;&ensp;中的数组去实现它。<br>&ensp;&ensp;下面是栈的实现<br>&ensp;&ensp;我们利用 dataStore 来保存栈内元素，初始化为空数组，top 属性用于记录当前栈顶位置，初始化的时候为0，<br>&ensp;&ensp;表示栈顶对应数组的起始位置是0，如果有元素入栈，则该属性会随之反生变化。<br>&ensp;&ensp;栈的方法:<br>&ensp;&ensp;push向栈内压入一个元素<br>&ensp;&ensp;pop像栈取出一个元素<br>&ensp;&ensp;peek查看栈顶元素<br>&ensp;&ensp;length：返回栈内元素总数<br>&ensp;&ensp;clear：清空栈<br>&ensp;&ensp;具体实现得代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">function Stack() &#123;</span><br><span class="line">  this.dataStore = [];//初始化为空</span><br><span class="line">  this.top = 0; //记录栈顶位置</span><br><span class="line">  this.pop = pop;//出栈</span><br><span class="line">  this.push = push;//入栈</span><br><span class="line">  this.peek = peek;//查看栈顶元素</span><br><span class="line">  this.length = length;//查看栈内元素总数</span><br><span class="line">  this.clear = clear;//清空栈</span><br><span class="line">&#125;</span><br><span class="line">//入栈</span><br><span class="line">function push(ele) &#123;</span><br><span class="line">this.dataStore[this.top++] = ele;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//出栈</span><br><span class="line">function pop() &#123;</span><br><span class="line">  return this.dataStore[--this.top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//查看栈顶的元素</span><br><span class="line">function peek() &#123;</span><br><span class="line">if(this.top &gt;0) &#123;</span><br><span class="line">  return this.dataStore[this.top];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//查看栈里面元素的数量</span><br><span class="line">function length() &#123;</span><br><span class="line">   return this.top;</span><br><span class="line">&#125;</span><br><span class="line">//清空栈</span><br><span class="line">function clear() &#123; </span><br><span class="line">   delete this.dataStore;</span><br><span class="line">   this.dataStore = [];</span><br><span class="line">   this.top = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/sushengxi/sushengxi.git.io.git/sushengxi.git.io/2018/01/22/Nodejs-log4js的使用/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="little su">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/sushengxi.git.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="little su的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/sushengxi.git.io/2018/01/22/Nodejs-log4js的使用/" itemprop="url">Nodejs log4js的使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-22T15:05:59+08:00">
                2018-01-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#Nodejs中间件<br>&ensp;&ensp;一.log4js的使用非常简单:<br>&ensp;&ensp;&ensp;&ensp;1.安装包(npm install log4js)<br>&ensp;&ensp;&ensp;&ensp;2.创建日志目录(./logs/log_fie/)<br>&ensp;&ensp;&ensp;&ensp;3.添加一个日志输出规则的配置文件(log4js.json)(这个也是有缺省的,但往往缺省配置是不满足使用需求的)<br>&ensp;&ensp;&ensp;&ensp;4.代码中加载log4js,并将配置文件获取到调用一下配置方法(log4js.configure(cfg.json))<br>&ensp;&ensp;&ensp;&ensp;5.写日志log4js.getLogger(‘log_test’).debug(“随便写日志啦!!!”)<br>&ensp;&ensp;二.Log4js的配置详解<br>&ensp;&ensp;1.appenders属性<br>&ensp;&ensp;appenders是配置文件的一级属性:它的作用是配置输出源.后续我们真正输出日志的对象就是appenders的下属子项标注的输出&ensp;&ensp;源appenders的子属性.<br>&ensp;&ensp;1.1 category配置<br>&ensp;&ensp;category翻译过来叫做种类.实际上更简单的理解成这个写日志员工的名字.<br>&ensp;&ensp;当我们有多个员工时就依靠与这个字段来区分,前面例子中,写日志前有这样一行code:<br>&ensp;&ensp;log4js.getLogger(‘log_file’).debug(…);<br>&ensp;&ensp;这个getLogger()的参数就是category的配置内容,可以是任意字符串<br>&ensp;&ensp;1.2 type配置<br>&ensp;&ensp;type字段是控制日志输出对象的是什么类型的,比较常用的配置有三个:<br>&ensp;&ensp;&ensp;&ensp;a.”type”:”console”:<br>&ensp;&ensp;&ensp;&ensp;type配置为console表示控制台,在此种配置下,往往用于调试时.细节参见2.replaceConsole中的描述.<br>&ensp;&ensp;b.”type”:”file”:<br>&ensp;&ensp;&ensp;&ensp;type配置为file表示日志输出为普通文件,在此种配置下,日志会输出到目标文件夹的目标文件中,并会随着文件大小的变化自动份文件.<br>&ensp;&ensp; 该模式下的具体生成文件方法:<br>&ensp;&ensp;相关有效配置包含:maxLogSize,backups,filename<br>&ensp;&ensp;相关无效配置包含:pattern,alwaysIncludePattern<br>&ensp;&ensp;c.”type”:”datefile”<br>&ensp;&ensp;type配置为datefile表示是输出按时间分文件的日志,在此种配置下,日志会输出到目标目录下,并以时间格式命名,随着时间的&ensp;&ensp;推移,以时间格式命名的文件如果尚未存在,则自         动创建新的文件.<br>&ensp;&ensp;该模式下的具体生成文件方法:<br>&ensp;&ensp;相关有效配置包含:pattern,alwaysIncludePattern,filename<br>&ensp;&ensp;相关无效配置包含:maxLogSize,backups<br>&ensp;&ensp;1.3 filename配置<br>&ensp;&ensp;a.filename是一个目录加上文件名,路径就是日志文件存储的路径.<br>&ensp;&ensp; b.此路径可以是相对路径也可以绝对路径,当是相对路径时,是相对于工程根目录.<br>&ensp;&ensp;c.无论是相对路径还是绝对路径,路径过程中的所有文件夹必须事先手动创建好,log4js不会自动创建,如路径不存在则会报错.<br>&ensp;&ensp;d.最后的文件名就是输出文件的名字模版,真实的名字会一定的修改,<br>&ensp;&ensp;&ensp;&ensp;d1:type:datefile 时会加上时间标签,如 [log-2015-01-24 , log-2015-01-25]<br>&ensp;&ensp;&ensp;&ensp;d2:type:file时 如果文件过大,份文件后会增加一个编号标签. [log.1 log.2 log.3 …]<br>&ensp;&ensp;1.4 maxLogSize配置<br>&ensp;&ensp;这个只在type:file模式有效.表示文件多大时才会创建下一个文件,单位是字节.实际设置时具体的值根据业务来定,但是不推荐&ensp;&ensp;大于100Mb.<br>&ensp;&ensp;1.5 pattern配置<br>&ensp;&ensp;这个只在type:datefile模式有效.表示一个文件的时间命名模式.在生成文件中会依照pattern配置来在filename的文件结尾&ensp;&ensp;追加一个时间串来命名文件.上个例子:<br>&ensp;&ensp;&ensp;&ensp;配置文件内容:<br>&ensp;&ensp;&ensp;&ensp;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;category&quot;:&quot;log_date&quot;,</span><br><span class="line">&quot;type&quot;: &quot;dateFile&quot;,</span><br><span class="line">&quot;filename&quot;: &quot;./logs/log_date/date&quot;,</span><br><span class="line">&quot;alwaysIncludePattern&quot;: true,</span><br><span class="line">&quot;pattern&quot;: &quot;-yyyy-MM-dd-hh:mm:ss.log&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;此时生成的文件名就是date-2015-01-24-14:24:12.log<br>&ensp;&ensp;pattern精确到ss(秒)就是一秒一个文件,精确到mm(分)就是一分一个文件,一次类推:hh(小<br>&ensp;&ensp;时),dd(天),MM(月),yyyy(年),yy(年后两位),注意大小写!<br>&ensp;&ensp;pattern是有默认配置的,默认配置是”.yyyy-MM-dd”<br>&ensp;&ensp;1.6 alwaysIncludePattern:<br>&ensp;&ensp;这个只在type:datefile模式有效.<br>&ensp;&ensp;这个是个开关配置 ture(默认值)是开启pattern,false是不开启pattern,不开启时datefile文件将无任何时间后缀,也不会&ensp;&ensp;分文件.<br>&ensp;&ensp;1.7 backups配置<br>&ensp;&ensp;这个只在type:file模式有效,表示备份的文件数量,如果文件过多则会将最旧的删除.<br>&ensp;&ensp;type:file模式下log4js的命名规则:正在写的文件就叫filename中配置的文件名,文件过大后会追加数字 例如 log.1 log.2 &ensp;&ensp;log.3 , 直至文件数量达到backups时会把最旧的删除.<br>&ensp;&ensp;当创建一个新的文件时,log4js会把所有之前的文件的.数字编号都顺延一位,最后将刚刚出现的大文件后面追加.1; 这种模式下&ensp;&ensp;应该注意大文件拷贝时对命名的影响,所以maxLogSize不要设置过大.<br>&ensp;&ensp;2.replaceConsole配置<br>&ensp;&ensp;这个配置是表示是否替换控制台输出.当配置文件中配置了appenders中配置了type:console的员工,并且&ensp;&ensp;replaceConsole:true时,代码中控制台输出(console.log  console.error)的内容将会以log4js格式输出到控制台中.<br>&ensp;&ensp;再说一个很实用的小技巧:log4js的时时调试输出:<br>&ensp;&ensp;当我们把实际生产环境的log4js.json配置好后,在调试阶段,日志会输出到各个文件中,试试调试起来很不方便,那么我们可以将各个日志输出员工的type配置为console,这样日志信息就会全都汇总到控制台输出.<br>&ensp;&ensp;此时如果再添加一个如下日志员工配置,则代码中nodejs系统提供的console.log也会输出到控制台中.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;:&quot;console&quot;,</span><br><span class="line">  &quot;category&quot;:&quot;console&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;其中category的名字必须叫console,否则无效,<br>&ensp;&ensp;replaceConsole:ture时如果不加这行,nodejs系统提供的console.log()输出的内容将不会显示<br>&ensp;&ensp;3.levels配置<br>&ensp;&ensp;levels配置也是一个一级属性,它控制着日志的输出级别.在发布的程序,如果很稳定,一些不重要的日志是需要隐去的,但当调试阶段或者环境异常时我们需要重现所有流程,就需要全面的日志.<br>&ensp;&ensp;levels的结构中配置着若干个属性,一般与appenders中的员工对应,其中属性名是appenders中的员工名(也就是category的值),属性值是一个表示等级的字符串.<br>&ensp;&ensp;log4js的levels配置共分为8个等级(也就是日志等级),由低到高分别为:ALL TRACE DEBUG INFO WARN ERROR FATAL OFF.<br>&ensp;&ensp;只有大于等于日志配置级别的信息才能输出出来.<br>&ensp;&ensp;三.Log4js的常见问题和小技巧<br>&ensp;&ensp;配置文件的格式设定<br>&ensp;&ensp;配置文件其实就是一个js对象,json,js,或者自己通过各种set方法赋值出来一个都一样<br>&ensp;&ensp;最开始说需要将配置文件与配置文件log4js.json与log4js模块关联,也就是调用configure()函数加载配置,其实此时就是需&ensp;&ensp;要一个JavaScript对象而已,既然如此,我们完全可以把配置文件写成js格式的文件,类似于这样的:<br>&ensp;&ensp;module.exports = { … 这里面的内容就是上面贴的json啦};<br>&ensp;&ensp;这种模型的优势是如果配置中有动态信息,可以在配置中添加函数,比如用文件名以pid命名,在配置时可以动态获取pid然后字符&ensp;&ensp;串拼接到filename上.另一个优势是json不支持注释,写成js后可以添加注释.<br>&ensp;&ensp;下面是我在项目里面log4js的配置文件</p>
<hr>
<p><img src="log4jsconfig.png" alt="mongodb"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/sushengxi/sushengxi.git.io.git/sushengxi.git.io/2018/01/20/Nodejs中间件/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="little su">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/sushengxi.git.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="little su的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/sushengxi.git.io/2018/01/20/Nodejs中间件/" itemprop="url">Nodejs中间件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-20T14:57:56+08:00">
                2018-01-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##Nodejs中间件<br>&ensp;&ensp; 首先理解一下中间件的概念：<br>&ensp;&ensp;中间件：是一个函数，它可以访问请求对象（request）, 响应对象（response）, 和 web 应用中处于请求-响应循环流程中的&ensp;&ensp;中间件(next)。(来源：express官网)著作权归作者所  有。<br>&ensp;&ensp;中间件的功能包括：<br>   &ensp;&ensp;&ensp;&ensp;执行任何代码。<br>   &ensp;&ensp;&ensp;&ensp;修改请求和响应对象。<br>   &ensp;&ensp;&ensp;&ensp;终结请求-响应循环。<br>   &ensp;&ensp;&ensp;&ensp;调用堆栈中的下一个中间件<br>   &ensp;&ensp;&ensp;&ensp;简单说中间件就是在请求过程中可以修改内容<br>&ensp;&ensp;下面是中间件的使用</p>
<hr>
<p><img src="usezjj.png" alt="mongodb"></p>
<hr>
<p>当你访问localhost:3001首先会进入上面的中间件 然后这个中间件执行完成之后会调用下一个中件件 直到该请求响应结束<br>上面代码片段里面的next()<br>  其实，它表示是下一个中间件(函数)，也就是第一个的中间件(函数)中的next是第二个中间件(函数)，如果你不调用next，就不会调用下一个中间件(函数)，也就是说到此结束了。而express的逻辑是只有所有中间件都被执行了，才会执行路由，也就是说，如果上面的实例中，第二个中间件不调用next，就不会执行route路由<br>下面是一个router路由的例子</p>
<hr>
<p><img src="router.png" alt="mongodb"></p>
<hr>
<p>&ensp;&ensp;上面路由的例子中  第一参数是url 第二个参数是对应的业务逻辑</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/sushengxi/sushengxi.git.io.git/sushengxi.git.io/2017/11/03/javascript异步的几种方式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="little su">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/sushengxi.git.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="little su的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/sushengxi.git.io/2017/11/03/javascript异步的几种方式/" itemprop="url">javascript异步的几种方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-03T15:49:28+08:00">
                2017-11-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="javascript异步的几种方式"><a href="#javascript异步的几种方式" class="headerlink" title="javascript异步的几种方式"></a>javascript异步的几种方式</h2><p>&ensp;&ensp;javascript中异步的几种方式<br>&ensp;&ensp;javascript语言的执行环境是”单线程”（single thread，就是指一次只能完成一件任务。如果有多个任务，就必须排队，前&ensp;&ensp;面一个任务完成，再执行后面一个任务，以此类推）。<br>&ensp;&ensp;这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖&ensp;&ensp;延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段Javascript代码长时间运行（比如死循环），导致整&ensp;&ensp;个页面卡在这个地方，其他任务无法执行。<br>&ensp;&ensp;为了解决这个问题，Javascript语言将任务的执行模式分成两种：同步（Synchronous）和异步（Asynchronous）。<br>&ensp;&ensp;“同步模式” 就是必须等待上一个任务完成才能进行下一个任务”异步模式”则完全不同，每一个任务有一个或多个回调函数&ensp;&ensp;（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，&ensp;&ensp;所以程序的执行顺序与任务的排列顺序是不一致的、异步的。<br>&ensp;&ensp;“异步模式” 非常重要。在浏览器端，耗时很长的操作都应该异步执行，避免浏览器失去响应.<br>&ensp;&ensp;处理异步的集中方式<br>&ensp;&ensp;&ensp;&ensp;1.callback(回调函数)<br>&ensp;&ensp;回调是一个函数被作为一个参数传递到另一个函数里，在那个函数执行完后再执行.<br>&ensp;&ensp;举例：<br>&ensp;&ensp;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">first()</span><br><span class="line">seconed()</span><br><span class="line">senconed等待first执行完成在执行</span><br><span class="line"></span><br><span class="line">function first(callback) &#123;</span><br><span class="line">    setTimeOut(() =&gt; &#123;</span><br><span class="line">       callback() </span><br><span class="line">    &#125;,5000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;first(seconed());<br>&ensp;&ensp;采用这种方式我们同步变成了异步，先执行程序的主要逻辑将比较好事的操作推迟执行<br>&ensp;&ensp;回调函数的优点是简单容易理解部署方便缺点是代码的耦合性太强，流程很混乱每一个函数只能有一个回调函数<br>&ensp;&ensp;这个地方有一个小细节就是回调不一定是异步他们之间没有直接的关系<br>&ensp;&ensp;举例：<br>&ensp;&ensp;同步回调<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function A(callback) &#123;</span><br><span class="line">    console.log(&quot;first&quot;);</span><br><span class="line">    callback();</span><br><span class="line">&#125;</span><br><span class="line">function B() &#123;</span><br><span class="line">    console.log(&quot;seconed&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;A(B);<br>&ensp;&ensp;异步回调:因为js是单线程的但是有很多操作执行步骤是很耗时的比如从远程获取资源（ajax)如果一直在单线程的堵塞下影响&ensp;&ensp;用户体验解决的方案就是耗时的都让异步去完成等完成了给我资源继续往下走<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&apos;POST&apos;, url, true);   //第三个参数决定是否采用异步的方式</span><br><span class="line">xhr.send(data);</span><br><span class="line">xhr.onreadystatechange = function()&#123;</span><br><span class="line">    if(xhr.readystate === 4 &amp;&amp; xhr.status === 200)&#123;</span><br><span class="line">       ///do something</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;上面这个是浏览器面发送ajax的例子<br>&ensp;&ensp;2.事件监听<br>&ensp;&ensp;事件监听采用的是事件驱动模式,事件的发生不是取决于代码的手续而是事件是否触发<br>&ensp;&ensp;监听函数有on,bind,addEventListeners,listener,observe<br>&ensp;&ensp;以first,seconed为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">first.on(&quot;done&quot;,seconed);(jquery的写法)</span><br><span class="line">function first() &#123;</span><br><span class="line">    setTimeOut(() =&gt; &#123;</span><br><span class="line">       first.trriger(&quot;done&quot;);</span><br><span class="line">    &#125;,1000)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;调用first()后立即触发first的done事件立即执行seconed;这种方式绑定的事件不局限于一个，而且代码的耦合性低，有利于&ensp;&ensp;模块化 而缺点是整个程序都是事件驱动类型的，运行流程会变得复杂不清楚，<br>&ensp;&ensp;1&gt;onclick方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ele.onclick = function() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;2&gt;attachEvent和addEvenListener方法<br>&ensp;&ensp;IE浏览器里面是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ele.attachEvent(&quot;onclick&quot;,handler0);</span><br><span class="line">ele.attachEvent(&quot;onclick&quot;,handler1);</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;非IE浏览器里面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ele.addEvenListener(&quot;click&quot;,hander0);</span><br><span class="line">ele.addEvenListener(&quot;click&quot;,hander1);</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;以上两种绑定方式执行的顺序 attachEvent 是从后往前 1-&gt;0 addEvenListener是从前往后 0-&gt;1,addEvenListener这个方&ensp;&ensp;法的第三个参数说明该事件是否冒泡<br>&ensp;&ensp;3&gt;发布订阅模式<br>&ensp;&ensp;什么事发布订阅模式：发布订阅模式，基于一个主题/事件通道，希望接收通知的对象（称为subscriber）通过自定义事件订阅&ensp;&ensp;主题，被激活事件的对象（称为publisher）通过发布主题事件的方式被通知。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.subscribe(&quot;done&quot;, f2);</span><br><span class="line">function first() &#123;</span><br><span class="line">    setTimeOut(() =&gt; &#123;</span><br><span class="line">        Object.publish(&quot;done&quot;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;取消订阅模式 Object.unsubscribe(“done”, f2)<br>&ensp;&ensp;4&gt;promise<br>&ensp;&ensp;promise是es6解决回调嵌套过深的方案（但是不止这一种）<br>    &ensp;&ensp;&ensp;&ensp;1&gt;promise是commonJS工作组提出的一种规范一种模式，目的是为了异步编程提供统一接口。<br>    &ensp;&ensp;&ensp;&ensp;2&gt;promise是一种模式，promise可以帮忙管理异步方式返回的代码。<br>    &ensp;&ensp;&ensp;&ensp;3&gt;promise完成之后，对应的代码也会执行。我们可以注册任意数量的函数再成功或者失败后运行，也可以&ensp;&ensp;在任何时候注册事件处理程序。<br>    &ensp;&ensp;4&gt;三种转态：pending/reslove/reject 。pending就是未解决，resolve可以理解为成功，reject可以理解为拒绝。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let promise = new Promise(function(resolve,reject) &#123;</span><br><span class="line">    setTimeOut(function() &#123;</span><br><span class="line">        let result;</span><br><span class="line">        if(result) &#123;</span><br><span class="line">            resolve(result);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            reject(&quot;Error&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(function(value) &#123;</span><br><span class="line">   //成功</span><br><span class="line">&#125;).catch(function(e) &#123;</span><br><span class="line">   //失败</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;这样写的优点是回调函数写成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现很多强大的功能但&ensp;&ensp;是也有他的缺点就是没有promise 回调函数是横向增长 而promise回调增多则纵向增长</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/sushengxi/sushengxi.git.io.git/sushengxi.git.io/2017/05/23/mongodb管道/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="little su">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/sushengxi.git.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="little su的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/sushengxi.git.io/2017/05/23/mongodb管道/" itemprop="url">mongodb管道</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-23T14:27:35+08:00">
                2017-05-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#mongodb管道<br>&ensp;&ensp;mongoDB的聚合框架模型建立在数据处理管道这一概念的基础之上。文档进入多阶段管道中，管道将文档转换为聚合结果。最基&ensp;&ensp;本的管道阶段类似于查询过滤器和修改输出文档形式的文档转换器。<br>&ensp;&ensp;其他的管道为分组和排序提供一些工具，可通过指定一个或多个字段完成分组或排序；同时提供了聚合数组内容的工具，操作的&ensp;&ensp;数组包括文档数组。另外，聚合阶段能够使用一些运算符，完成诸如计算均值或连接字符串之类的任务。<br>&ensp;&ensp;管道利用MongoDB本机的操作方法提供了有效的数据聚合操作，并且对于数据聚合来说采用本机的操作方法是首选的。<br>&ensp;&ensp;聚合管道支持在分片集合上执行操作。<br>&ensp;&ensp;数据还用之前聚合里面的这些<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.collection.save(&#123;&quot;name&quot;:&quot;s&quot;,&quot;sex&quot;:&quot;男&quot;,&quot;age&quot;:1,&quot;score&quot;:100&#125;)</span><br><span class="line">db.collection.save(&#123;&quot;name&quot;:&quot;a&quot;,&quot;sex&quot;:&quot;男&quot;,&quot;age&quot;:2,&quot;score&quot;:100&#125;)</span><br><span class="line">db.collection.save(&#123;&quot;name&quot;:&quot;d&quot;,&quot;sex&quot;:&quot;女&quot;,&quot;age&quot;:3,&quot;score&quot;:100&#125;)</span><br><span class="line">db.collection.save(&#123;&quot;name&quot;:&quot;g&quot;,&quot;sex&quot;:&quot;女&quot;,&quot;age&quot;:1,&quot;score&quot;:100&#125;)</span><br><span class="line">db.collection.save(&#123;&quot;name&quot;:&quot;h&quot;,&quot;sex&quot;:&quot;男&quot;,&quot;age&quot;:1,&quot;score&quot;:100&#125;)</span><br><span class="line">db.collection.save(&#123;&quot;name&quot;:&quot;k&quot;,&quot;sex&quot;:&quot;女&quot;,&quot;age&quot;:1,&quot;score&quot;:100&#125;)</span><br><span class="line">db.collection.save(&#123;&quot;name&quot;:&quot;p&quot;,&quot;sex&quot;:&quot;男&quot;,&quot;age&quot;:1,&quot;score&quot;:600&#125;)</span><br><span class="line">db.collection.save(&#123;&quot;name&quot;:&quot;u&quot;,&quot;sex&quot;:&quot;女&quot;,&quot;age&quot;:1,&quot;score&quot;:20&#125;)</span><br></pre></td></tr></table></figure></p>
<p>$project 对数据进行修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.aggregate([&#123;&quot;$project&quot;:&#123;&quot;name&quot;:1,&quot;score&quot;:1&#125;&#125;])</span><br></pre></td></tr></table></figure></p>
<p><img src="project.png" alt="mongodb"><br>$match 对数据进行过滤(如果是Number类型一定是数字不能是字符串)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.aggregate([&#123;&quot;$match&quot;:&#123;&quot;score&quot;:&#123;&quot;$gt&quot;:100&#125;&#125;&#125;])</span><br></pre></td></tr></table></figure></p>
<p><img src="match.png" alt="mongodb"><br>$skip 对查询的数据跳过指定数量的文档，返回剩下数量的文档<br>首先查找scroe小于等于100的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.aggregate([&#123;&quot;$match&quot;:&#123;&quot;score&quot;:&#123;&quot;$lte&quot;100&#125;&#125;&#125;])</span><br></pre></td></tr></table></figure></p>
<p><img src="lte.png" alt="mongodb"></p>
<hr>
<p>然后跳过前三条的数据返回剩下的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.aggregate([&#123;&quot;$match&quot;:&#123;&quot;score&quot;:&#123;&quot;$lte&quot;100&#125;&#125;&#125;,&#123;&quot;$skip&quot;:3&#125;])</span><br></pre></td></tr></table></figure></p>
<hr>
<p><img src="lte.png" alt="mongodb"></p>
<hr>
<p>$limt 限制返回数据的条数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.aggregate([&#123;&quot;$match&quot;:&#123;&quot;score&quot;:&#123;&quot;$lte&quot;:100&#125;&#125;&#125;,&#123;&quot;$limit&quot;:3&#125;])</span><br></pre></td></tr></table></figure></p>
<hr>
<p><img src="match.png" alt="mongodb"></p>
<hr>
<p>$unwind 将数组里面中的每个值拆分为单独的文档<br>我们先在数据库里面插入下面的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.save(&#123;&quot;name&quot;:&quot;ssx&quot;,&quot;age&quot;:20,&quot;firends&quot;:[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;]&#125;)</span><br></pre></td></tr></table></figure></p>
<p>由于数据库有很多数据我们先找到我们方才插入的那一条 然后以firends分为单独的文档</p>
<hr>
<p><img src="unwind.png" alt="mongodb"></p>
<hr>
<p>$sort 可以根据任何字段（或者多个字段）进行排序，与在普通查询中的语法是相同的。如果要对大量的文档进行排序，强烈建议在管道的第一阶段进行排序，这时的排序操作可以使用索引。否则，排序过程就会比较慢，而且会占用大量内存。<br>1是升序，-1是降序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.find(&#123;&#125;).sort(&#123;&quot;score&quot;:1&#125;)</span><br></pre></td></tr></table></figure></p>
<hr>
<p><img src="all.png" alt="mongodb"></p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/sushengxi/sushengxi.git.io.git/sushengxi.git.io/2017/03/23/javascript原型/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="little su">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/sushengxi.git.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="little su的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/sushengxi.git.io/2017/03/23/javascript原型/" itemprop="url">javascript 原型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-23T14:27:35+08:00">
                2017-03-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="javascript原型"><a href="#javascript原型" class="headerlink" title="javascript原型"></a>javascript原型</h2><h5 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h5><p>每一个对象都与一个可以继承属性的原型对象相关联。从对象文字创建的所有对象都链接到Object.prototype，这是一个JavaScript标准对象<br>所有引用类型（函数，数组，对象）都拥有&#95;&#95;proto&#95;&#95;属性（隐式原型）<br>所有函数拥有prototype属性（显式原型）（仅限函数）<br>原型对象：拥有prototype属性的对象，在定义函数时就被创建<br>&#95;&#95;proto&#95;&#95;：是一个对象拥有的内置属性，是JS内部使用寻找原型链的属性。可以理解为它是一个指针，用于指向创建它的函数对象的原型对象prototype（即构造函数的prototype）用chrome和FF都可以访问到对象的<strong>proto</strong>属性，IE不可以。</p>
<h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Dog(name,age) &#123;</span><br><span class="line">   this.dogname= name;</span><br><span class="line">   this.dongage = age;</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype.eat = function() &#123;</span><br><span class="line">   console.log(&quot;Host i like eat meat&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let mydog = new Dog(&quot;菲菲&quot;,1);</span><br><span class="line">mydog.eat();</span><br></pre></td></tr></table></figure>
<p>实例mydog的隐式原型&#95;&#95;proto&#95;&#95;指向的是他构造函数的显示原型prototype<br><code>mydog.__proto__===Dog.prototype</code><br>当调用某种方法或查找某种属性时，首先会在自身调用和查找，如果自身并没有该属性或方法，则会去它的&#95;&#95;proto&#95;&#95;属性中调用查找，也就是它构造函数的prototype中调用查找。所以很好理解实例继承构造函数的方法和属性：<br>mydog本身没有eat方法，所以会去Dog的显式原型中调用eat，即实例继承构造函数的方法。</p>
<h5 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.a = &quot;w&quot;;</span><br><span class="line">Object.prototype.b = &quot;b&quot;</span><br><span class="line">function Dog(name,age) &#123;</span><br><span class="line">    this.dogName = name;</span><br><span class="line">    this.dogAge = age;</span><br><span class="line">&#125;</span><br><span class="line">let mydog = new Dog(&apos;菲菲&apos;,1);</span><br><span class="line">console.log(mydog.a) //打印1</span><br><span class="line">console.log(mydog.b) //打印2</span><br></pre></td></tr></table></figure>
<p>上面打印结构 打印1是undefiend 打印2是原因是:<br> mydog是Dog()的实例，是一个Dog对象，它拥有一个属性值&#95;&#95;proto&#95;&#95;，并且&#95;&#95;proto&#95;&#95;是一个对象，包含两个属性值constructor和&#95;&#95;proto&#95;&#95;<br>我们打印一下mydog的&#95;&#95;proto&#95;&#95;属性和constructor属性<br><code>console.log(mydog.__proto__.constructor)
  console.log(mydog.__proto__.__proto__)</code><br>结果如下</p>
<hr>
<p><img src="proto1.png" alt="mongodb"></p>
<hr>
<p>我们调用constructor属性，mydog.&#95;&#95;proto&#95;&#95;.&#95;&#95;proto&#95;&#95;.constructor得到的是Object()函数，Dog.prototype的隐式原型的constructor指向Object()，即Dog.prototype.<strong>proto</strong>.constructor == Object()<br>从mydog.&#95;&#95;proto&#95;&#95;.constructor返回的结果为构造函数本身 Dog.prototype.constructor == Dog()所以mydog.<strong>_proto</strong>.<strong>proto</strong>== Object.prototype<br>所以mydog.b打印结果为b，mydot没有b属性，会一直通过&#95;&#95;proto&#95;&#95;向上查找，最后当查找到Object.prototype时找到，最后打印出b，向上查找过程中，得到的是Object.prototype，而不是Function.prototype，找不到a属性，所以结果为undefined，这就是原型链，通过&#95;&#95;proto&#95;&#95;向上进行查找，最终到null结束</p>
<p>总结：</p>
<ul>
<li>查找属性，如果本身没有，则会去&#95;&#95;proto&#95;&#95;中查找，也就是构造函数的显式原型中查找，如果构造函数的显式原型中也没有该属性，则继续向构造函数的显式原型的&#95;&#95;proto&#95;&#95;中查找，一直到null，如果没有则返回undefined</li>
<li>mydog.&#95;&#95;proto&#95;&#95;.constructor  == function Dog(){}</li>
<li>mydog.&#95;&#95;proto&#95;&#95;.&#95;&#95;proto&#95;&#95;== Object.prototype</li>
<li>mydog.&#95;&#95;proto&#95;&#95;.&#95;&#95;proto&#95;&#95;.&#95;&#95;proto&#95;&#95;== Object.prototype.&#95;&#95;proto&#95;&#95; == null         </li>
<li>通过&#95;&#95;proto&#95;&#95;形成原型链而非protrotype<br>结合下面的图片更容易理解原型和原型链<br><img src="prototype.png" alt="mongodb"></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/sushengxi/sushengxi.git.io.git/sushengxi.git.io/2017/03/23/mondodb聚合/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="little su">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/sushengxi.git.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="little su的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/sushengxi.git.io/2017/03/23/mondodb聚合/" itemprop="url">mongodb聚合</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-23T14:27:35+08:00">
                2017-03-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="mongodb聚合"><a href="#mongodb聚合" class="headerlink" title="mongodb聚合"></a>mongodb聚合</h2><p>&ensp;&ensp;MongoDB中聚合(aggregate)主要用于处理数据(诸如统计平均值,求和等)，并返回计算后的数据结果。有点类似sql语句中的 count(*)。<br>基本语法为：db.collection.aggregate( [ &lt;stage1&gt;, &lt;stage2&gt;, … ] )<br>我们在数据库中插入一下文档：</p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.collection.save(&#123;&quot;name&quot;:&quot;s&quot;,&quot;sex&quot;:&quot;男&quot;,&quot;age&quot;:1,&quot;score&quot;:100&#125;)</span><br><span class="line">db.collection.save(&#123;&quot;name&quot;:&quot;a&quot;,&quot;sex&quot;:&quot;男&quot;,&quot;age&quot;:2,&quot;score&quot;:100&#125;)</span><br><span class="line">db.collection.save(&#123;&quot;name&quot;:&quot;d&quot;,&quot;sex&quot;:&quot;女&quot;,&quot;age&quot;:3,&quot;score&quot;:100&#125;)</span><br><span class="line">db.collection.save(&#123;&quot;name&quot;:&quot;g&quot;,&quot;sex&quot;:&quot;女&quot;,&quot;age&quot;:1,&quot;score&quot;:100&#125;)</span><br><span class="line">db.collection.save(&#123;&quot;name&quot;:&quot;h&quot;,&quot;sex&quot;:&quot;男&quot;,&quot;age&quot;:1,&quot;score&quot;:100&#125;)</span><br><span class="line">db.collection.save(&#123;&quot;name&quot;:&quot;k&quot;,&quot;sex&quot;:&quot;女&quot;,&quot;age&quot;:1,&quot;score&quot;:100&#125;)</span><br></pre></td></tr></table></figure>
<hr>
<p>&ensp;&ensp;执行下面的语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.aggregate([&#123;&quot;$group&quot;:&#123;&quot;_id&quot;:&quot;$sex&quot;,&quot;personCount&quot;:&#123;&quot;$sum&quot;:1&#125;&#125;&#125;])</span><br></pre></td></tr></table></figure></p>
<p>对性别sex进行分组并统计他们的数量</p>
<hr>
<p><img src="personcount.png" alt="mongodb"></p>
<hr>
<p>&ensp;&ensp;由于上面的数据看效果不是太明显 我们在插入两条数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.collection.save(&#123;&quot;name&quot;:&quot;p&quot;,&quot;sex&quot;:&quot;男&quot;,&quot;age&quot;:1,&quot;score&quot;:600&#125;)</span><br><span class="line">db.collection.save(&#123;&quot;name&quot;:&quot;u&quot;,&quot;sex&quot;:&quot;女&quot;,&quot;age&quot;:1,&quot;score&quot;:20&#125;)</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;对性别进行分组然后对score进行求平均值 $avg<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dv.collection.aggregate([&quot;$group&quot;:&#123;&quot;_id&quot;:&quot;$sex&quot;,&quot;scoreAvg&quot;:&#123;&quot;$avg&quot;:&quot;$score&quot;&#125;&#125;&#125;])</span><br></pre></td></tr></table></figure></p>
<hr>
<p><img src="scoreavg.png" alt="mongodb"></p>
<hr>
<p>&ensp;&ensp;对性别进行分组然后求最大值 $max<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.aggregate([&quot;$group&quot;:&#123;&quot;_id&quot;:&quot;$sex&quot;,&quot;scoreMax&quot;:&#123;&quot;$max&quot;:&quot;$score&quot;&#125;&#125;])</span><br></pre></td></tr></table></figure></p>
<hr>
<p><img src="scoreavg.png" alt="mongodb"></p>
<hr>
<p>&ensp;&ensp;对性别进行分组然后取最小值 $min<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.aggregate([&quot;$group&quot;:&#123;&quot;_id&quot;:&quot;$sex&quot;,&quot;scoreMin&quot;:&#123;&quot;$min&quot;:&quot;$score&quot;&#125;&#125;])</span><br></pre></td></tr></table></figure></p>
<hr>
<p><img src="scoreavg.png" alt="mongodb"></p>
<hr>
<p>&ensp;&ensp;对性别进行分组然后将score放进一个数组scores $push<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.aggregate([&quot;$group&quot;:&#123;&quot;_id&quot;:&quot;$sex&quot;,&quot;scores&quot;:&#123;&quot;$push&quot;:&quot;$score&quot;&#125;&#125;])</span><br></pre></td></tr></table></figure></p>
<hr>
<p><img src="push.png" alt="mongodb"></p>
<hr>
<p>对性别进行分组然后将score放进一个数组scores去掉重复的元素 $addToSet<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.aggregate([&quot;$group&quot;:&#123;&quot;_id&quot;:&quot;$sex&quot;,&quot;scores&quot;:&#123;&quot;$addToSet&quot;:&quot;$score&quot;&#125;&#125;])</span><br></pre></td></tr></table></figure></p>
<hr>
<p><img src="addtoset.png" alt="mongodb"></p>
<hr>
<p>根据资源文档的排序获取第一个元素 $first<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.aggregate([&quot;$group&quot;:&#123;&quot;_id&quot;:&quot;$sex&quot;,&quot;firstelement&quot;:&#123;&quot;$first&quot;:&quot;$score&quot;&#125;&#125;])</span><br></pre></td></tr></table></figure></p>
<hr>
<p><img src="firstelement.png" alt="mongodb"></p>
<hr>
<p>根据资源文档的排序获取最后一个元素 $last<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.aggregate([&quot;$group&quot;:&#123;&quot;_id&quot;:&quot;$sex&quot;,&quot;lastelement&quot;:&#123;&quot;$last&quot;:&quot;$score&quot;&#125;&#125;])</span><br></pre></td></tr></table></figure></p>
<hr>
<p><img src="last.png" alt="mongodb"></p>
<hr>
<p>全部统计不进行分组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.aggregate([&quot;$group&quot;:&#123;&quot;_id&quot;:&quot;null&quot;,&quot;totalScore&quot;:&#123;&quot;$push&quot;:&quot;$score&quot;&#125;&#125;])</span><br></pre></td></tr></table></figure></p>
<hr>
<p><img src="all.png" alt="mongodb"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/sushengxi.git.io/page/2/">2</a><a class="extend next" rel="next" href="/sushengxi.git.io/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">little su</p>
              <p class="site-description motion-element" itemprop="description">h5，javascript,css,node,java,mysql,mongodb</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/sushengxi.git.io/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">little su</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/sushengxi.git.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/sushengxi.git.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/sushengxi.git.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/sushengxi.git.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/sushengxi.git.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/sushengxi.git.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/sushengxi.git.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/sushengxi.git.io/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/sushengxi.git.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
